#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

//HELPER
//Read all characters in a file
char* readAllText(char* path)
{
    //Text buffer to be returned
    char* text;
    //File to be read from
	FILE *f;
    //If opening of the file fails
	if((f = fopen(path,"r"))==NULL)
	{
        //output about file not existing
		printf("File %s doesn't exist!\n",path);
        //Close the program
		exit(-1);
	}
    //Seek the end of the file
	fseek(f,0,SEEK_END);
    //Allocate enough space for the entire file
	text = malloc(ftell(f));
    //Rewind the file back to beginning
	fseek(f,0,SEEK_SET);
    //Declare counter for the character array
	long count = 0;
    //Initialise buffer for single character
	char c;
    //Iterate for as long as the character is not
    //the end of the file
	while((c = fgetc(f))!=EOF)
	{
        //Add the character
		text[count++] = (char)c;
	}
    //Close the file
    fclose(f);
    //Return the source
    return text;
}

//TOKENIZER
//Type of a token
typedef enum silentTokenType
{
	silentUnrecognisedToken,
	//Symbols
	silentPlusToken,
	silentMinusToken,
	silentMultiplyToken,
	silentDivideToken,
	silentParenthesToken,
	silentCurlyBracketToken,
	silentBracketToken,
	silentQuotationToken,
	silentSemicolonToken,
	silentAssignToken,

	//Structure
	silentClassToken,
	silentFunctionToken,
	silentStructToken,
	silentArrayToken,
    silentVariableToken,
	
	//Access
	silentPublicToken,
	silentPrivateToken,
	silentProtectedToken,

	//Data
	silentNullToken,
	silentVoidToken,
	silentStringToken,
	silentIntegerToken,
	silentFloatToken,
	silentLongToken,
	silentDoubleToken,
	silentIdentifierToken
}silentTokenType;

//Token structure
typedef struct silentToken
{
    //Type of the token
	silentTokenType type;
    //Value of the token
	char* value;
}silentToken;

//Tokenizer
//Extract the array of tokens from source
silentToken* silentTokenize(char* source, int* count)
{
	//Current character
	long currentChar = 0;
	//Current line
	long currentLine = 0;
	//Character buffer for parsing
    char buffer[255];
	//Array of tokens
	silentToken* tokens = malloc(strlen(source));

	//Iterate through the source
	for(int i = 0; i < strlen(source); i++)
	{
		//Create new token
		silentToken token;
		//Assign unrecognised token type by default
		token.type = silentUnrecognisedToken;
		//Assign the value to "NULL" by default
		token.value = "NULL";

		//Test for semicolon
		if(source[i] == ';')
		{
			token.type = silentSemicolonToken;
			token.value = ";";
		}

		//Test for assignment
		else if(source[i] == '=')
		{
			token.type = silentAssignToken;
			token.value = "=";
		}
		//Test for parentheses
		else if((source[i] == '(') || (source[i] == ')'))
		{
			//Assign the parentheses type
			token.type = silentParenthesToken;
			//Allocate 2 bytes for the string
			token.value = malloc(2);
			//Assign first character to the parentheses
			token.value[0] = source[i];
			//Null terminate the string
			token.value[1] = '\0';
		}

		//Test for curly brackets
		else if((source[i] == '{') || (source[i] == '}'))
		{
			//Assign the parentheses type
			token.type = silentCurlyBracketToken;
			//Allocate 2 bytes for the string
			token.value = malloc(2);
			//Assign first character to the parentheses
			token.value[0] = source[i];
			//Null terminate the string
			token.value[1] = '\0';
		}

		//Test for multicharacter tokens
		else if(isalpha(source[i]))
		{
			//Number of characters
			unsigned char count = 0;
			//prepare space for the value
			char* value;
			//As long as the current character isn't whitespace
			while(isalpha(source[i+count]) ||
				isdigit(source[i+count]))
			{
				//Assign buffer to the current character
				buffer[count++] = source[i+count];
			}
			//Allocate space for the value and terminator
			value = malloc(count+1);
			//Copy the value from the buffer
			memcpy(value,buffer,count);
			value[count] = '\0';
			token.value = value;
			token.type = silentIdentifierToken;
			//Test for non-identifier tokens
			//If the token is a function
			if(strcmp(token.value, "func"))
			{
				token.type = silentFunctionToken;
			}
			else if(strcmp(token.value, "var"))
			{
				token.type = silentVariableToken;
			}
			else if(strcmp(token.value, "int"))
			{
				token.type = silentIntegerToken;
			}
			else if(strcmp(token.value, "float"))
			{
				token.type = silentFloatToken;
			}
			i += count-1;
		}

		//Test for numbers
		else if(isdigit(source[i]))
		{
			char* value;
			char floatVal = 0;
			char count = 0;
			while(isdigit(source[i]))
			{
				buffer[count] = source[i];
				i++;
				count++;
			}

			//Allocate space for the value and terminator
			
			value = malloc(count+1);
			//Copy the value from the buffer
			memcpy(value,buffer,count);
			value[count] = '\0';
			token.value = value;
			token.type = silentIntegerToken;
			if(floatVal){token.type = silentFloatToken;}
            //i += count-1;
		}

		//Test for quotations
		else if(source[i] == *"\"")
		{
			token.type = silentQuotationToken;
			token.value = "";
			for(int j = 1; source[i+j] != *"\"";j++)
			{
				token.value += source[i+j];
			}
		}

		//Test for whitespaces
		else if(isspace(source[i]))
		{
			continue;
		}

		else{
			continue;
		}
		tokens[i] = token;
		*count++;
		printf("%s\n",token.value);
	}
	return tokens;
}

//PARSER
//Type of a node
typedef enum silentNodeType
{
	//Value
	silentStringNode,
	silentIntegerNode,
	silentFloatNode,

	//Functionality
	silentAdditionNode,
	silentSubtractionNode,
	silentMultiplicationNode,
	silentDivisionNode,
	silentAssignNode,
	silentReturnNode,

	//Structure
	silentIfNode,
	silentWhileNode,
	silentForNode,
	silentFunctionNode,
}silentNodeType;

//Node for a value
typedef struct silentValue
{
	//Type of the node
	silentNodeType type;
	//Value of the node
	char* value;
}silentValue;

//Node for an expression
typedef struct silentExpression
{
	//Type of the node
	silentNodeType type;
	//Expression parameters
	//E.G. 2 + 2; 
	//type: addition; parameters: 2, 2
	silentValue parameters[2];
}silentExpression;

//Node for a function
typedef struct silentFunction
{
	//Array of expressions
	silentExpression* expressions;
	//Name of the function
	char* name;
	//Return type
	silentTokenType returnType;
	//Parameters
	silentValue* parameters;
	//Number of parameters
	int parameterCount;
}silentFunction;

//Node for the program
typedef struct silentProgram
{
	//Number of functions
	int functionCount;
	//Function array
	silentFunction* functions;
}silentProgram;

//Parse a function
silentFunction* silentParseFunction(silentToken* tokens, int* index)
{
	//Set up the function
	silentFunction function;
	*index++;
	
	if(!(
		(tokens[*index].type == silentIntegerToken) ||
		(tokens[*index].type == silentStringToken) ||
		(tokens[*index].type == silentFloatToken) ||
		(tokens[*index].type == silentVoidToken)
	))
	{
		//Implement custom type return type
		printf("Invalid return type\n");
		exit(0);
	}

	*index++;

	if(tokens[*index].type != silentIdentifierToken)
	{
		printf("Expected funtion name\n");
		exit(0);
	}

	function.name = tokens[*index].value;

	*index++;

	if(tokens[*index].type != silentParenthesToken)
	{
		printf("Expected parentheses for function %s\n",function.name);
	}

	while(1)
	{
		switch(tokens[*index].type)
		{
			
		}
		*index++;
	}
}

silentProgram* silentGenerateAST(silentToken* tokens, int tokenCount)
{
	for(int i = 0; i < tokenCount; i++)
	{
		switch(tokens[i].type)
		{
			case silentFunctionNode:
				silentParseFunction(tokens,&i);
			break;

			default:
				printf("Invalid token in the global scope\n");
			break;
		}
	}
}

char* silentCompile(char* path, char* output)
{
	char* rawSource = readAllText(path);//no AST
	int tokenCount;
	silentToken* tokens = silentTokenize(rawSource,&tokenCount);
	silentGenerateAST(tokens,tokenCount);
}

//Testing
int main()
{
	char* source = "test.silent";
	char* out = "out";
	silentCompile(source,out);
	return 0;
}
